# -*- coding: utf-8 -*-
"""streamlit_app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14eOtUISATGXLxFHqfr0WLVDFLVsuG3WS
"""

# streamlit_app.py
import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from datetime import datetime


st.title("ðŸ“Š 6-Month Transaction Analysis")

# Raw CSV GitHub URL
url = "https://raw.githubusercontent.com/Matshisela/imali_simulation_24/refs/heads/main/data/transaction_data_6_months.csv"

@st.cache_data(ttl=600)  # refresh every 10 minutes
def load_data():
    return pd.read_csv(url, parse_dates=['timestamp'])

df = load_data()


# Set page config
st.set_page_config(
    page_title="Transaction Analytics Dashboard",
    page_icon="ðŸ“Š",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Sidebar filters
st.sidebar.header("Filters")
date_range = st.sidebar.date_input(
    "Date range",
    value=[df['timestamp'].min().date(), df['timestamp'].max().date()], # Access 'timestamp' column and extract date
    min_value=df['timestamp'].min().date(), # Access 'timestamp' column and extract date
    max_value=df['timestamp'].max().date() # Access 'timestamp' column and extract date
)

if len(date_range) == 2:
    start_date, end_date = date_range
    # Convert start_date and end_date to datetime objects for comparison with 'timestamp'
    start_datetime = datetime.combine(start_date, datetime.min.time())
    end_datetime = datetime.combine(end_date, datetime.max.time())
    filtered_df = df[(df['timestamp'] >= start_datetime) & (df['timestamp'] <= end_datetime)] # Filter by 'timestamp'
else:
    filtered_df = df

services = st.sidebar.multiselect(
    "Services",
    options=df['service'].unique(),
    default=df['service'].unique()
)

payment_methods = st.sidebar.multiselect(
    "Payment Methods",
    options=df['payment_method'].unique(),
    default=df['payment_method'].unique()
)

statuses = st.sidebar.multiselect(
    "Transaction Status",
    options=df['status'].unique(),
    default=df['status'].unique()
)

# Apply filters
filtered_df = filtered_df[
    (filtered_df['service'].isin(services)) &
    (filtered_df['payment_method'].isin(payment_methods)) &
    (filtered_df['status'].isin(statuses))
]

# Dashboard title
st.title("ðŸ“Š Transaction Analytics Dashboard")
st.markdown("""
    <style>
    .big-font {
        font-size:18px !important;
        color: #2a9fd6;
    }
    </style>
    <p class="big-font">Key metrics and insights to drive data-informed decisions</p>
    """, unsafe_allow_html=True)

# KPI Metrics
st.subheader("Key Performance Indicators")
col1, col2, col3, col4 = st.columns(4)

with col1:
    total_transactions = filtered_df.shape[0]
    delta_transactions = (total_transactions / df.shape[0] * 100) - 100
    st.metric(
        label="Total Transactions",
        value=f"{total_transactions:,}",
        delta=f"{delta_transactions:.1f}% vs total period"
    )

with col2:
    total_amount = filtered_df['amount'].sum()
    avg_amount = filtered_df['amount'].mean()
    st.metric(
        label="Total Amount Processed",
        value=f"${total_amount:,.2f}",
        delta=f"Avg: ${avg_amount:.2f}"
    )

with col3:
    success_rate = (filtered_df[filtered_df['status'] == 'Success'].shape[0] / filtered_df.shape[0]) * 100
    st.metric(
        label="Success Rate",
        value=f"{success_rate:.1f}%",
        delta="0% target" if success_rate == 100 else f"{success_rate-100:.1f}% below target"
    )

with col4:
    unique_users = filtered_df['user_id'].nunique()
    st.metric(
        label="Unique Users",
        value=f"{unique_users:,}",
        delta=f"{unique_users / df['user_id'].nunique() * 100:.1f}% of total users"
    )

# First row of charts
st.subheader("Transaction Trends")
col1, col2 = st.columns(2)

with col1:
    # Daily transaction volume
    # Extract date part from 'timestamp' and group by date
    daily_trans = filtered_df.groupby(filtered_df['timestamp'].dt.date)['transaction_id'].count().reset_index()
    daily_trans.columns = ['date', 'transaction_id'] # Rename column for plotting
    fig = px.line(
        daily_trans,
        x='date',
        y='transaction_id',
        title='Daily Transaction Volume',
        labels={'date': 'Date', 'transaction_id': 'Number of Transactions'}
    )
    fig.update_layout(height=400)
    st.plotly_chart(fig, use_container_width=True)

with col2:
    # Transaction amount distribution
    fig = px.box(
        filtered_df,
        y='amount',
        title='Transaction Amount Distribution',
        labels={'amount': 'Amount ($)'}
    )
    fig.update_layout(height=400)
    st.plotly_chart(fig, use_container_width=True)

# Second row of charts
col1, col2 = st.columns(2)

with col1:
    # Transactions by service
    service_counts = filtered_df['service'].value_counts().reset_index()
    fig = px.pie(
        service_counts,
        names='service',
        values='count',
        title='Transactions by Service',
        hole=0.3
    )
    fig.update_layout(height=400)
    st.plotly_chart(fig, use_container_width=True)

with col2:
    # Transactions by payment method
    payment_counts = filtered_df['payment_method'].value_counts().reset_index()
    fig = px.bar(
        payment_counts,
        x='payment_method',
        y='count',
        title='Transactions by Payment Method',
        labels={'payment_method': 'Payment Method', 'count': 'Count'},
        color='payment_method'
    )
    fig.update_layout(height=400)
    st.plotly_chart(fig, use_container_width=True)

# Third row of charts
st.subheader("Operational Metrics")
col1, col2 = st.columns(2)

with col1:
    # Success rate by payment method
    success_rates = filtered_df.groupby('payment_method')['status'].apply(
        lambda x: (x == 'Success').mean() * 100
    ).reset_index()
    fig = px.bar(
        success_rates,
        x='payment_method',
        y='status',
        title='Success Rate by Payment Method',
        labels={'payment_method': 'Payment Method', 'status': 'Success Rate (%)'},
        color='payment_method'
    )
    fig.update_layout(height=400)
    st.plotly_chart(fig, use_container_width=True)

with col2:
    # Hourly transaction pattern
    # Ensure 'timestamp' column exists before accessing 'hour'
    if 'timestamp' in filtered_df.columns:
         # Extract hour from the 'timestamp' column
        hourly_counts = filtered_df['timestamp'].dt.hour.value_counts().sort_index().reset_index()
        hourly_counts.columns = ['hour', 'count'] # Rename columns
        fig = px.line(
            hourly_counts,
            x='hour',
            y='count',
            title='Hourly Transaction Pattern',
            labels={'hour': 'Hour of Day', 'count': 'Number of Transactions'}
        )
        fig.update_layout(height=400)
        st.plotly_chart(fig, use_container_width=True)
    else:
        st.warning("Timestamp column not found. Cannot display hourly transaction pattern.")


# Fourth row - Advanced metrics
st.subheader("Advanced Analytics")
col1, col2 = st.columns(2)

with col1:
    # Customer segmentation by transaction count
    user_transactions = filtered_df['user_id'].value_counts().reset_index()
    user_transactions.columns = ['user_id', 'transaction_count']
    fig = px.histogram(
        user_transactions,
        x='transaction_count',
        title='Customer Segmentation by Transaction Frequency',
        labels={'transaction_count': 'Number of Transactions per User'},
        nbins=20
    )
    fig.update_layout(height=400)
    st.plotly_chart(fig, use_container_width=True)

with col2:
    # Device usage
    device_counts = filtered_df['device'].value_counts().reset_index()
    fig = px.pie(
        device_counts,
        names='device',
        values='count',
        title='Transactions by Device',
        hole=0.3
    )
    fig.update_layout(height=400)
    st.plotly_chart(fig, use_container_width=True)

# Raw data view
st.subheader("Raw Data View")
st.dataframe(filtered_df.sort_values('timestamp', ascending=False), height=300) # Sort by 'timestamp'

# Download button
st.download_button(
    label="Download Filtered Data as CSV",
    data=filtered_df.to_csv(index=False).encode('utf-8'),
    file_name='filtered_transactions.csv',
    mime='text/csv'
)

